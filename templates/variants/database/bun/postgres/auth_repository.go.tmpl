package auth

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/uptrace/bun"

	"{{.ModuleName}}/internal/database"
)

// RefreshTokenRepo handles refresh token persistence using Bun ORM.
type RefreshTokenRepo struct {
	db *bun.DB
}

// NewRefreshTokenRepository creates a new Bun-based refresh token repository.
func NewRefreshTokenRepository(db *bun.DB) *RefreshTokenRepo {
	return &RefreshTokenRepo{db: db}
}

// StoreRefreshToken stores a refresh token in the database
func (r *RefreshTokenRepo) StoreRefreshToken(ctx context.Context, userID uuid.UUID, token string, expiresAt time.Time) error {
	tokenHash := hashToken(token)

	dbToken := &database.RefreshToken{
		UserID:    userID,
		TokenHash: tokenHash,
		ExpiresAt: expiresAt,
	}

	_, err := r.db.NewInsert().
		Model(dbToken).
		Exec(ctx)
	if err != nil {
		return fmt.Errorf("failed to store refresh token: %w", err)
	}

	return nil
}

// GetRefreshToken retrieves a refresh token by its hash
func (r *RefreshTokenRepo) GetRefreshToken(ctx context.Context, token string) (*RefreshToken, error) {
	tokenHash := hashToken(token)

	dbToken := new(database.RefreshToken)
	err := r.db.NewSelect().
		Model(dbToken).
		Where("token_hash = ?", tokenHash).
		Scan(ctx)

	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, ErrRefreshTokenNotFound
		}
		return nil, fmt.Errorf("failed to get refresh token: %w", err)
	}

	return mapDBRefreshTokenToModel(dbToken), nil
}

// RevokeRefreshToken marks a refresh token as revoked
func (r *RefreshTokenRepo) RevokeRefreshToken(ctx context.Context, token string) error {
	tokenHash := hashToken(token)

	result, err := r.db.NewUpdate().
		Model((*database.RefreshToken)(nil)).
		Set("revoked_at = NOW()").
		Where("token_hash = ?", tokenHash).
		Exec(ctx)
	if err != nil {
		return fmt.Errorf("failed to revoke refresh token: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to check rows affected: %w", err)
	}

	if rowsAffected == 0 {
		return ErrRefreshTokenNotFound
	}

	return nil
}

// RevokeAllUserTokens revokes all refresh tokens for a user
func (r *RefreshTokenRepo) RevokeAllUserTokens(ctx context.Context, userID uuid.UUID) error {
	_, err := r.db.NewUpdate().
		Model((*database.RefreshToken)(nil)).
		Set("revoked_at = NOW()").
		Where("user_id = ?", userID).
		Where("revoked_at IS NULL").
		Exec(ctx)
	if err != nil {
		return fmt.Errorf("failed to revoke all user tokens: %w", err)
	}

	return nil
}

// CleanupExpiredTokens removes expired tokens from the database
// Should be run periodically (e.g., via cron job)
func (r *RefreshTokenRepo) CleanupExpiredTokens(ctx context.Context) error {
	_, err := r.db.NewDelete().
		Model((*database.RefreshToken)(nil)).
		Where("expires_at < NOW()").
		Exec(ctx)
	if err != nil {
		return fmt.Errorf("failed to cleanup expired tokens: %w", err)
	}

	return nil
}

// mapDBRefreshTokenToModel converts database model to domain model
func mapDBRefreshTokenToModel(dbt *database.RefreshToken) *RefreshToken {
	return &RefreshToken{
		ID:        dbt.ID,
		UserID:    dbt.UserID,
		TokenHash: dbt.TokenHash,
		ExpiresAt: dbt.ExpiresAt,
		CreatedAt: dbt.CreatedAt,
		RevokedAt: dbt.RevokedAt,
	}
}
