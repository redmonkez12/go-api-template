package auth

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/uptrace/bun"

	"go-api-template/internal/database"
)

// RefreshTokenRepo implements RefreshTokenRepository using Bun ORM.
type RefreshTokenRepo struct {
	db *bun.DB
}

// NewRefreshTokenRepository creates a new Bun-based refresh token repository.
func NewRefreshTokenRepository(db *bun.DB) *RefreshTokenRepo {
	return &RefreshTokenRepo{db: db}
}

// StoreRefreshToken stores a new refresh token in the database.
func (r *RefreshTokenRepo) StoreRefreshToken(ctx context.Context, userID uuid.UUID, token string, expiresAt time.Time) error {
	tokenHash := hashToken(token)

	dbToken := &database.RefreshToken{
		UserID:    userID.String(),
		TokenHash: tokenHash,
		ExpiresAt: expiresAt,
	}

	_, err := r.db.NewInsert().
		Model(dbToken).
		Exec(ctx)
	if err != nil {
		return fmt.Errorf("failed to store refresh token: %w", err)
	}

	return nil
}

// GetRefreshToken retrieves a refresh token by its token value.
func (r *RefreshTokenRepo) GetRefreshToken(ctx context.Context, token string) (*RefreshToken, error) {
	tokenHash := hashToken(token)

	var dbToken database.RefreshToken
	err := r.db.NewSelect().
		Model(&dbToken).
		Where("token_hash = ?", tokenHash).
		Scan(ctx)

	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, ErrRefreshTokenNotFound
		}
		return nil, fmt.Errorf("failed to get refresh token: %w", err)
	}

	return mapDBRefreshTokenToModel(&dbToken), nil
}

// RevokeRefreshToken marks a refresh token as revoked.
func (r *RefreshTokenRepo) RevokeRefreshToken(ctx context.Context, token string) error {
	tokenHash := hashToken(token)
	now := time.Now()

	result, err := r.db.NewUpdate().
		Model((*database.RefreshToken)(nil)).
		Set("revoked_at = ?", now).
		Where("token_hash = ?", tokenHash).
		Where("revoked_at IS NULL").
		Exec(ctx)

	if err != nil {
		return fmt.Errorf("failed to revoke refresh token: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to check rows affected: %w", err)
	}

	if rowsAffected == 0 {
		return ErrRefreshTokenNotFound
	}

	return nil
}

// RevokeAllUserTokens revokes all refresh tokens for a user.
func (r *RefreshTokenRepo) RevokeAllUserTokens(ctx context.Context, userID uuid.UUID) error {
	now := time.Now()

	_, err := r.db.NewUpdate().
		Model((*database.RefreshToken)(nil)).
		Set("revoked_at = ?", now).
		Where("user_id = ?", userID.String()).
		Where("revoked_at IS NULL").
		Exec(ctx)
	if err != nil {
		return fmt.Errorf("failed to revoke all user tokens: %w", err)
	}

	return nil
}

// CleanupExpiredTokens removes expired tokens from the database.
func (r *RefreshTokenRepo) CleanupExpiredTokens(ctx context.Context) error {
	_, err := r.db.NewDelete().
		Model((*database.RefreshToken)(nil)).
		Where("expires_at < NOW()").
		Exec(ctx)
	if err != nil {
		return fmt.Errorf("failed to cleanup expired tokens: %w", err)
	}

	return nil
}

// mapDBRefreshTokenToModel converts database model to domain model.
func mapDBRefreshTokenToModel(dbToken *database.RefreshToken) *RefreshToken {
	userID, _ := uuid.Parse(dbToken.UserID)
	return &RefreshToken{
		ID:        dbToken.ID,
		UserID:    userID,
		TokenHash: dbToken.TokenHash,
		ExpiresAt: dbToken.ExpiresAt,
		CreatedAt: dbToken.CreatedAt,
		RevokedAt: dbToken.RevokedAt,
	}
}
